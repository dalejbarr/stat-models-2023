#+AUTHOR: Statistical Models
#+DATE: Psychology, University of Glasgow

#+REVEAL_INIT_OPTIONS: width:1200, height:800, margin: 0.1, minScale:0.2, maxScale:2.5, transition:'fade'
#+OPTIONS: toc:nil num:nil ^:nil
#+REVEAL_THEME: black
#+REVEAL_HLEVEL: 2
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Correlation and Regression">
#+REVEAL_POSTAMBLE: <p> Created by Dale Barr </p>
#+REVEAL_PLUGINS: (markdown notes)
#+REVEAL_EXTRA_CSS: ./local.css

#+REVEAL_ROOT: ./reveal.js
#+REVEAL_HLEVEL: 2

#+REVEAL_TITLE_SLIDE_BACKGROUND: ../img/titlescreen.png
#+REVEAL_HIGHLIGHT_CSS: %r/lib/css/zenburn.css

#+TITLE: Linear mixed-effects modeling with crossed random factors
#+PROPERTY: header-args:R :session *R* :exports both :results output

* Setup                                                            :noexport:

#+begin_src R :results silent
  options(crayon.enabled = FALSE)
  library("tidyverse")
  library("lme4")
  library("funfact")

  three_way_mixed <- function() {
    my_design <- list(ivs = c(A = 2, B = 2, C = 2),
		      n_item = 16,
		      between_subj = sample(LETTERS[1:3], 1))

    dat <- sim_norm(my_design, 8, params = gen_pop(my_design, 8)) %>%
      as_tibble() %>%
      select(subj_id, A, B, C, DV = Y) %>%
      sample_n(nrow(.))

    list(my_design, dat)
  }

  three_way_mixed_both <- function() {
    n_subj <- 16L
    n_item <- 16L
    if (sample(c(TRUE, FALSE), 1L)) {
      n_subj <- 8L
    } else {
      n_item <- 8L
    }
    my_design <- c(list(ivs = c(A = 2, B = 2, C = 2),
			n_item = n_item))

    dat <- sim_norm(my_design, n_subj, params = gen_pop(my_design, n_subj)) %>%
      as_tibble() %>%
      select(subj_id, item_id, A, B, C, DV = Y) %>%
      sample_n(nrow(.))

    list(my_design, dat)  
  }  

  set.seed(9122005)
  dat1 <- three_way_mixed()[[2]]
  dat2 <- three_way_mixed_both()[[2]]
#+end_src


* overview

- generalizing to subjects and stimuli
  - dealing with "crossed" random factors

- random effects in complex designs

- non-convergence and model validation

* generalizing to subjects and stimuli

*** Language-as-fixed-effect fallacy

  - Psycholinguistic experiments sample language materials as well as subjects
  - Language stimuli should be treated as a random, not fixed factor
  - Clark's suggestion: \(F'\), min-\(F'\)
  - Modern solution: Linear-mixed effects with crossed random factors of subjects and stimuli

  #+begin_citation
  Baayen, R. H., Davidson, D. J., & Bates, D. M. (2008). [[https://doi.org/10.1016/j.jml.2007.12.005][Mixed-effects modeling with crossed random effects for subjects and items.]] /Journal of Memory and Language/, /59/, 390-412.

  Clark, H. H. (1973). [[https://doi.org/10.1016/S0022-5371(73)80014-3][The language-as-fixed-effect fallacy: A critique of language statistics in psychological research]]. /Journal of Verbal Learning and Verbal Behavior/, /12/, 335-359.
  #+end_citation

*** Crossed random factors

#+REVEAL_HTML: <div class="column" style="float:left; width: 20%">

#+REVEAL_HTML: <div class="tab1">

#+begin_src R :exports results :results output
    subj <- tibble(subj_id = 1:4, list_id = c(1:2, 2:1))
    subj
#+end_src

#+REVEAL_HTML: </div></div>

#+REVEAL_HTML: <div class="column" style="float:left; width: 30%">

#+REVEAL_HTML: <div class="tab2">

#+begin_src R :exports results :results output
    lists <- tibble(list_id = rep(1:2, each = 4),
		    stim_id = rep(LETTERS[1:4], 2),
		    condition = rep(c("treatment", "control",
				      "control", "treatment"),
				    each = 2))
    lists
#+end_src

#+REVEAL_HTML: </div></div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 50%">

#+REVEAL_HTML: <div class="tab3">

#+begin_src R :exports both :results output
    inner_join(subj, lists, "list_id")
#+end_src

#+RESULTS:
#+begin_example
     subj_id list_id stim_id condition
  1        1       1       A treatment
  2        1       1       B treatment
  3        1       1       C   control
  4        1       1       D   control
  5        2       2       A   control
  6        2       2       B   control
  7        2       2       C treatment
  8        2       2       D treatment
  9        3       1       A treatment
  10       3       1       B treatment
  11       3       1       C   control
  12       3       1       D   control
  13       4       2       A   control
  14       4       2       B   control
  15       4       2       C treatment
  16       4       2       D treatment
#+end_example

#+REVEAL_HTML: </div></div>

*** generalizing over encounters
    :LOGBOOK:
    CLOCK: [2019-11-13 Wed 20:37]
    :END:

  The target of inference in much of psychology and related fields has
  been misidentified as a population of /subjects/ or /stimuli/, when the
  actual target of inference is a population of events: *encounters*

  #+begin_smaller
  - readers encountering particular types of words
  - male participants judging attractiveness of female faces, or vice versa
  - gamers encountering particular types of violent games
  - audience members encountering particular types of dance movements
  - insomniacs (versus controls) encountering emotional expressions
  - birds hearing particular types of birdsongs
  #+end_smaller

  #+begin_citation
  Barr, D. J. (2018). Generalizing Over Encounters. In the /Oxford Handbook of Psycholinguistics./
  #+end_citation


* specifying random effects

*** general procedure for factorial designs

for each random factor (subjects/stimuli):

1. identify within-unit factors
2. check highest-order combination of within-subject factors
   - /NO pseudoreplications:/ no random slopes
   - /YES pseudoreplications:/ all interactions/main effects get slopes

/between-unit factors (or interactions involving them) never get random slopes/

#+begin_citation
  Barr, D. J. (2013). [[https://doi.org/10.3389/fpsyg.2013.00328][Random effects structure for testing interactions in linear mixed-effects models]]. /Frontiers in Psychology/, /4/, 328.

  Barr, D. J., Levy, R., Scheepers, C., & Tily, H. J. (2013). [[https://doi.org/10.1016/j.jml.2012.11.001][Random effects structure for confirmatory hypothesis testing: Keep it maximal]]. /Journal of Memory and Language/, /68/, 255-278.
#+end_citation

*** determining the design from data

three way design, subjects only random factor

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">

#+reveal_html: <div class="tab1">

#+NAME: threewaymixed
#+begin_src R :exports results :results output
	  dat1
#+end_src

#+RESULTS: threewaymixed
#+begin_example
# A tibble: 128 x 5
   subj_id A     B     C          DV
     <int> <chr> <chr> <chr>   <dbl>
 1       5 A1    B1    C2     4.80  
 2       5 A1    B2    C1     7.40  
 3       1 A2    B1    C2     0.444 
 4       6 A2    B1    C2     3.97  
 5       4 A1    B1    C2     2.90  
 6       4 A1    B2    C1    -0.0699
 7       3 A1    B2    C2     2.75  
 8       1 A2    B2    C2     2.86  
 9       3 A1    B2    C2     0.452 
10       8 A1    B1    C1    -0.694 
# … with 118 more rows
#+end_example

#+REVEAL_HTML: </div></div>

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">

#+REVEAL_HTML: <div class="tab2">

#+begin_src R :exports both :results output
  count(dat1, subj_id, A, B, C)
#+end_src

#+RESULTS:
#+begin_example
# A tibble: 32 x 5
   subj_id A     B     C         n
     <int> <chr> <chr> <chr> <int>
 1       1 A2    B1    C1        4
 2       1 A2    B1    C2        4
 3       1 A2    B2    C1        4
 4       1 A2    B2    C2        4
 5       2 A2    B1    C1        4
 6       2 A2    B1    C2        4
 7       2 A2    B2    C1        4
 8       2 A2    B2    C2        4
 9       3 A1    B1    C1        4
10       3 A1    B1    C2        4
# … with 22 more rows
#+end_example

#+REVEAL_HTML: </div></div>

$A$ is between, $BC$ within, 4 obs / cell

=DV ~ A * B * C + (B * C | subj_id)=

*** example with crossed random factors

=DV ~ A * B * C + (? | subj_id) + (? | item_id)=

#+REVEAL_HTML: <div class="tab1">

#+begin_src R :exports both :results output
  dat2
#+end_src

#+RESULTS:
#+begin_example
# A tibble: 128 x 6
   subj_id item_id A     B     C         DV
     <int>   <int> <chr> <chr> <chr>  <dbl>
 1       7      13 A1    B2    C2     1.41 
 2       3       6 A1    B1    C2     3.62 
 3       3       1 A2    B2    C2     2.79 
 4       2       4 A1    B2    C1    -1.41 
 5       4      10 A2    B1    C1     0.971
 6       7       5 A2    B2    C2     8.12 
 7       7      16 A2    B1    C1     7.66 
 8       6       3 A2    B1    C1     3.00 
 9       7      10 A1    B1    C2     0.644
10       6       9 A2    B2    C2    10.7  
# … with 118 more rows
#+end_example

#+REVEAL_HTML: </div>

*** by-subject random effects

#+REVEAL_HTML: <div class="tab1">

#+begin_src R :exports both :results output
  dat2 %>%
    count(subj_id, A, B, C)
#+end_src

#+RESULTS:
#+begin_example
# A tibble: 64 x 5
   subj_id A     B     C         n
     <int> <chr> <chr> <chr> <int>
 1       1 A1    B1    C1        2
 2       1 A1    B1    C2        2
 3       1 A1    B2    C1        2
 4       1 A1    B2    C2        2
 5       1 A2    B1    C1        2
 6       1 A2    B1    C2        2
 7       1 A2    B2    C1        2
 8       1 A2    B2    C2        2
 9       2 A1    B1    C1        2
10       2 A1    B1    C2        2
# … with 54 more rows
#+end_example

#+REVEAL_HTML: </div>

#+begin_src R :eval never :exports code
DV ~ A * B * C + (A * B * C | subj_id) + (? | item_id)
#+end_src

*** by-stimulus random effects

#+REVEAL_HTML: <div class="tab2">

#+begin_src R :exports both :results output
  dat2 %>%
    count(item_id, A, B, C)
#+end_src

#+RESULTS:
#+begin_example

# A tibble: 128 x 5
   item_id A     B     C         n
     <int> <chr> <chr> <chr> <int>
 1       1 A1    B1    C1        1
 2       1 A1    B1    C2        1
 3       1 A1    B2    C1        1
 4       1 A1    B2    C2        1
 5       1 A2    B1    C1        1
 6       1 A2    B1    C2        1
 7       1 A2    B2    C1        1
 8       1 A2    B2    C2        1
 9       2 A1    B1    C1        1
10       2 A1    B1    C2        1
# … with 118 more rows
#+end_example

#+REVEAL_HTML: </div>

#+begin_src R :eval never :exports code
DV ~ A * B * C + (A * B * C | subj_id) + (1 | item_id)
#+end_src

* non-convergence and model validation

** non-convergence

When you get a convergence warning you should in the first instance:

- double-check the model specification
- make sure all predictors are scaled and centred

then re-fit the model. If it still does not converge, seek to reduce
the random effects structure, but **proceed with caution.**

You can also try different optimizers (see =?lme4::convergence=)

/="model is singular"= is NOT a convergence warning/

*** reducing random effects structure

Reducing random effects can help convergence, but the worst thing you
can do is remove the slope for a theory-critical predictor.

1. Remove random correlations and re-fit
   - Use =(A * B || subject)= 

2. Worst case scenario: effectwise testing, e.g.:
   - test A using (A | subject) + (A | stimulus)
   - test B using (B | subject) + (B | stimulus)
   - test AB using (A:B | subject) + (A:B | stimulus)

** checking assumptions

- linearity
- homogeneity of variance
- normality of residuals
  - outliers
  - multimodality
  - other weirdness (skew, etc)

*** linearity

  - fitted (line) v. observed (points)

  #+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
  #+begin_src R
    mod <- lmer(Reaction ~ Days + 
		  (Days | Subject),
		sleepstudy, REML = FALSE)

    ## fitted values: 
    ##   fitted(mod)
    ## residuals:
    ##   residuals(mod)
  #+end_src
  #+REVEAL_HTML: </div>

  #+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
  #+begin_src R :exports results :results output graphics file :file fits.png
    ss2 <- mutate(sleepstudy, fits = fitted(mod))

    ggplot(ss2, aes(Days, Reaction)) +
      geom_line(aes(y = fits, group = Subject)) +
      geom_point() +
      facet_wrap(~Subject)
  #+end_src

  #+RESULTS:
  [[file:fits.png]]

  #+REVEAL_HTML: </div>

*** homogeneity of variance

  #+REVEAL_HTML: <div class="column" style="float:left; width: 50%">

  #+HEADER: :width 300 :height 300
  #+begin_src R :exports both :results output graphics file :file nhomog_cat.png
    n_obs <- 200L
    dat3 <- tibble(cond = rep(c("A", "B"), 
			      each = n_obs),
		   Y = c(rnorm(n_obs, 0, 100),
			 rnorm(n_obs, 0, 50)))

    ggplot(dat3, aes(cond, Y)) +
      geom_violin() +
      geom_jitter(alpha = .2)
  #+end_src
  #+RESULTS:
  [[file:nhomog_cat.png]]

  #+REVEAL_HTML: </div>

  #+REVEAL_HTML: <div class="column" style="float:right; width: 50%">

  #+HEADER: :width 300 :height 300
  #+begin_src R :results output graphics file :file nhomog_cont.png
    n_pts <- 10L
    n_obs <- 50
    dat4 <- tibble(
      x = seq_len(n_pts),
      y = map(x, # purrr::map()
	      ~ rnorm(n_obs, 5 * .x, 10 * .x))) %>%
      unnest() # tidyr::unnest()

    ggplot(dat4, aes(x, y)) +
      geom_point(alpha = .2) +
      geom_smooth(method = "lm")
  #+end_src

  #+REVEAL_HTML: </div>

*** normality of residuals

  - don't visualize the raw DV to check for normality!

  https://dalejbarr.shinyapps.io/raw_vs_resids/

*** visual checks

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
  - histogram

#+HEADER: :width 260 :height 260
#+begin_src R :results output graphics file :file histo.png
    ## resids from the model fit to sleepstudy
    my_resids <- residuals(mod)

    ## it is a vector, must put into a tibble
    ## for ggplot
    rtbl <- tibble(residual = my_resids)

    ggplot(rtbl, aes(residual)) +
      geom_histogram()
#+end_src

#+RESULTS:
  [[file:histo.png]]

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
- Q-Q plot (quantile-quantile)

#+HEADER: :width 300 :height 300
#+begin_src R :results output graphics file :file qqplot.png
    ## sadly there is no qqplot for ggplot
    ## so we use base::qqnorm()
    qqnorm(my_resids)
#+end_src

#+RESULTS:
[[file:qqplot.png]]

#+REVEAL_HTML: </div>

#+begin_citation
Vanhove, J. (2018). /Checking the assumptions of your statistical model without getting paranoid./ Preprint at https://psyarxiv.com/zvawb/.
#+end_citation
